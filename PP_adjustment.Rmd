---
title: "Pycnophylactic adjustment"
author: "Marko Kallio"
date: "24 November 2019"
output: html_document
---


## adjust smoothed surface so that it retains the original mass of the unsmoothed surface within specified zones


the following shows how to smooth a layer while keeping the mean of the original layer within specified zones.


```{r libs}
library(dplyr)
library(raster)
library(rasterVis)
library(gstat) # to create two artificial layers
library(knitr)
library(kableExtra) # nice html tables
```


### Define function

The function adjusts a smoothed raster based on the difference in means between the original raster and the smoothed raster). Pycnophylactic interpolation (PP) is applied to the difference, resulting in a smooth surface where of the errors, but where the mean error within the zone equals the original mean error. The smoothed input raster is then adjusted with the new surface. In practice, smoothing this way is a combination of the two surfaces: the original smoothed raster, and the smoothed error obtained from PP.
The function does not allow negative values in the smoothed raster. If they are present, they are set to zero. The function also keeps cells with value 0 as 0, and therefore any negative value are set to zero and kept there.

There is a current caveat in the function that it does not allow missing values within the specified zones (yet), or the function will result in error.


the inputs are:

* r1 = unsmoothed *RasterLayer*
* r2 = smoothed *RasterLayer*
* zones = rasterlayer defining zones for *raster::zonal()* function
* adjust_threshold = How much of the values in r2 is allowed to change in the adjustment. A value of 0.5 will allow 50% adjustment in r2 in order to restore balance with r1. The function checks whether this is possible - with small values, the zonal difference between r1 and r2 can be so high that it cannot be adjusted to match! 
* n = number of iterations for pycnophylactic interpolation
* smoothing_matrix = neighbourhood used in PP. Experimental, not recommended!
* intensive = TRUE (default) if the raster contains intensive (densitied, e.g. runoff depth), or extensive (counts, e.g. runoff volume) values.
* return_error =*TRUE* or *FALSE* whether to return the estimated error surface. If true, the function will return a *RasterStack* with the adjusted smooth layer, the original smooth layer, and the error layer.
* verbose = print progress indication?

function defitinion not shown.

```{r, echo=FALSE}

pycnophylactic_smoothing <- function(r1, r2, 
                                     zones, 
                                     adjust_threshold = NULL,
                                     n=50, 
                                     smoothing_matrix = matrix(1,3,3),
                                     intensive = TRUE,
                                     return_error = FALSE,
                                     verbose = FALSE) {
    
    if(verbose) message("Preparing..")
    
    # retain
    if(intensive) {
        r_zonal_mean <- raster::zonal(r1*area(r1), zones)
        rsm_zonal_mean <- raster::zonal(r2*area(r2), zones)
    } else {
        r_zonal_mean <- raster::zonal(r1, zones)
        rsm_zonal_mean <- raster::zonal(r2, zones)
    }
    
    zonal_diff <- cbind(r_zonal_mean, sm_mean = rsm_zonal_mean[,2])
    zonal_diff <- cbind(zonal_diff, diff = zonal_diff[,3]-zonal_diff[,2])
    
    rzd <- raster::reclassify(zones, zonal_diff[,c(1,4)])
    
    ## TEST WHETHER POSSIBLE
    diff_test <- zonal_diff[,4] / zonal_diff[,2]
    if(is.null(adjust_threshold)) adjust_threshold <- max(abs(diff_test))
    diff_test <- any(abs(diff_test) > adjust_threshold)
    
    
    
    # pycnophylactic interpolation
    if(verbose) message("Pycnophylactic interpolation of errors..")
    rzd_i <- as.matrix(rzd)
    ncol <- ncol(rzd)
    nrow <- nrow(rzd)
    # boundary condition
    rleft <- rzd_i[,1]
    rright <- rzd_i[,ncol]
    rtop <- c(NA, rzd_i[1,], NA)
    rbottom <- c(NA, rzd_i[nrow,], NA)
    
    if(intensive) {
        areas <- values(area(rzd))
    } else {
        areas <- 1
    }
    
    adj_tmpl <- tibble::tibble(pixel = 1:ncell(zones),
                               zone = values(zones), 
                               areas = areas,
                               r1 = values(r1) * areas,
                               smooth_r2 = values(r2) * areas,
                               no_change = smooth_r2 <= 0,
                               negative = smooth_r2 < 0,
                               max_err = abs(smooth_r2 *
                                                 adjust_threshold * 
                                                 !negative),
                               orig_err_mean = values(rzd))
    
    nochange <- matrix(adj_tmpl$no_change, nrow=nrow, ncol=ncol,
                       byrow=TRUE)
    
    
    ## TEST WHETHER POSSIBLE errors
    tst <- adj_tmpl %>% 
        dplyr::select(zone, max_err, orig_err_mean) %>%
        dplyr::group_by(zone) %>%
        dplyr::summarise(max_err = sum(max_err, na.rm=TRUE),
                  err = sum(orig_err_mean, na.rm=TRUE),
                  test = abs(err) > max_err)
    test <- any(tst$test)
    if(test) stop("cannot reallocate error with current threshold. Please increase.")
    if(!test && diff_test) warning(paste0("threshold smaller than difference ",
                                          "between r1 and r2. adjustment may ",
                                          "be unstable."))
    
    
    
    pb <- txtProgressBar(min = 0, max = n, style=3) 
    for(i in 1:n) {
        
        # add boundary condition
        rzd_i[nochange] <- 0
        rzd_i <- cbind(rleft, rzd_i, rright)
        rzd_i <- rbind(rtop, rzd_i, rbottom)
        
        # smooth
        rzd_i <- raster::raster(rzd_i)
        rzd_i <- raster::focal(rzd_i, 
                               w=smoothing_matrix, 
                               fun=mean, 
                               pad=TRUE, 
                               na.rm=TRUE)
        rzd_i <- as.matrix(rzd_i)[c(-1,-(nrow+1)), c(-1,-(ncol+1))]
        rzd_i[nochange] <- 0
        
        adj <- adj_tmpl %>%
            mutate(smooth_mean = as.vector(t(rzd_i))) %>%
            dplyr::group_by(zone) %>%
            dplyr::mutate(mean_sm = mean(smooth_mean, na.rm=TRUE),
                          adjust = ifelse(orig_err_mean == 0,
                                          1,
                                          (mean_sm)/(orig_err_mean)),
                          new_err = smooth_mean/adjust,
                          high_err = abs(new_err) > abs(max_err))
        
        iterr <- adj$new_err
        if(any(adj$high_err)) {
            
            uniq_zone <- unique(adj$zone)
            output <- list()
            for(z in uniq_zone) {
                if(is.na(z)) {
                    order <- adj %>% 
                        dplyr::filter(is.na(zone)) %>%
                        dplyr::select(zone, pixel, areas, orig_err_mean,
                               smooth_r2, max_err, new_err) %>%
                        dplyr::arrange(smooth_r2) %>% 
                        dplyr::mutate(fixed_err = new_err)
                    output <- append(output, list(order))
                    
                    next
                } 
                order <- adj %>% 
                    dplyr::filter(zone == z) %>%
                    dplyr::select(zone, pixel, areas, orig_err_mean,
                           smooth_r2, max_err, new_err, adjust) %>%
                    dplyr::arrange(smooth_r2)  
                
                max_err <- order$max_err
                new_err <- order$new_err
                fixed_err <- rep(NA, length(new_err))
                shares <- max_err / sum(abs(max_err))
                share_left <- sum(shares)
                shares_visited <- 0
                total_err <- 0
               
                for(j in seq_along(new_err)) {
                    share_of_err <- shares[j] / (1-shares_visited)
                    sherr <- total_err*share_of_err
                    test <- abs(new_err[j]+sherr) > abs(max_err[j])
                    if(is.na(test)) next
                    pos <- new_err[j] >= 0
                    if(test) {
                        
                        if(pos) {
                            dist_err = new_err[j] - max_err[j];
                            fix_err = max_err[j];
                        }  else {
                            dist_err = new_err[j] + max_err[j];
                            fix_err = -max_err[j];
                            # if(total_err >= 0) {
                            #     dist_err = new_err[j] + max_err[j];
                            #     fix_err = -max_err[j];
                            # } else {
                            #     dist_err = new_err[j] - max_err[j];
                            #     fix_err = -max_err[j];
                            # }
                            
                        }
                        
                        
                        shares_visited <- shares_visited + shares[j]
                        total_err <- total_err + dist_err
                        
                        fixed_err[j] <- fix_err
                        
                    } else {
                        fixed_err[j] <- new_err[j] + sherr
                        total_err <- total_err - sherr
                        shares_visited <- shares_visited + shares[j]
                    }
                }
               
                
                order <- order %>%
                    dplyr::mutate(fixed_err = fixed_err)
                output <- append(output, list(order))
            }
            output <- do.call(rbind, output) 
            output <- arrange(output, pixel)
            iterr <- output$fixed_err
        }
        rzd_i <- matrix(iterr, nrow=nrow, ncol=ncol,
                        byrow=TRUE)
        if(verbose) setTxtProgressBar(pb, i)
    }
    
    if(verbose) close(pb)
    
    message("Preparing output..")
    values(rzd) <- rzd_i 
    if(intensive) rzd <- rzd/area(rzd)
    sm_out <- r2 - rzd
    if(return_error) {
        out <- raster::stack(sm_out, r2, rzd)
        names(out) <- c("Adjusted", "Original", "Error")
        return(out)
    } else {
        return(sm_out)
    }
} 


```


### load wateruse data, and remove all values outside the zones. wateruse is resampled to the zones raster.
```{r}

w <- raster("data/wateruse_original_mm.tif")
wsm <- raster("data/wateruse_smoothed_mm.tif")

zones1 <- raster("data/zones_basins10000km2_mountainslowlands.tif")
crs(zones1) <- crs(w)
zones2 <- raster("data/zones_seabasins_mountainslowlands.tif")
crs(zones2) <- crs(w)
# zones_sf <- sf::read_sf("data/mountainslopes_vector.gpkg")
# zones <- fasterize::fasterize(zones_sf, zones1, field="id")



#zones1_rs <- resample(zones1, runoff, method="ngb")
w_rs <- resample(w, zones1, method="ngb")
wsm_rs <- resample(wsm, zones1, method="ngb")

nas <- is.na(values(w_rs))
nas2 <- is.na(values(wsm_rs))
nas3 <- is.na(values(zones1))
nas <- nas | nas2 | nas3
#values(runoff_rs) <- values(runoff_rs) * nas

val <- values(zones1)
val[nas] <- NA
values(zones1) <- val

val <- values(w_rs)
val[nas] <- NA
values(w_rs) <- val

val <- values(wsm_rs)
val[nas] <- NA
values(wsm_rs) <- val

```


### test water use, intensive

The function retains water balance (the volume of water within the zone), rather than the wateruse depth. This is because, if the input rasters cells are not rectangular, and in an equal area projection, the volume of water will change. 

```{r}

system.time({
    test <- pycnophylactic_smoothing(w_rs, wsm_rs, 
                                     zones1, n=5, adjust_threshold = 0.5,
                                     return_error = TRUE, verbose=TRUE)
})
```

### test whether the wateruse depth is preserved - NO
```{r}
zm_runoff <- raster::zonal(w_rs, zones1)
zm_runoff_smooth <- raster::zonal(test[[1]], zones1)
all.equal(zm_runoff, zm_runoff_smooth)
```

### test whether the volume of water use is preserved - YES
```{r}
zm_runoff <- raster::zonal(w_rs*area(w_rs), zones1)
zm_runoff_smooth <- raster::zonal(test[[1]]*area(test[[1]]), zones1)
all.equal(zm_runoff, zm_runoff_smooth)
```

### test also for any negative values in the raster
```{r}
any(round(values(test[[1]]),10) < 0, na.rm=TRUE)
```


### test water use, intensive

if the input water use was expressed in volume, we don't need to do extra work converting depth to volume to preserve water balance. Here, depth (as the imaginary volume) is preserved when intensive is set to FALSE.

```{r}

system.time({
    test <- pycnophylactic_smoothing(w_rs, wsm_rs, zones1, 
                                     intensive = FALSE, n=5, 
                                     adjust_threshold = 0.5,
                                     return_error = TRUE, verbose=TRUE)
})

```

### Test whether depth is preserved - YES
```{r}
zm_runoff <- raster::zonal(w_rs, zones1)
zm_runoff_smooth <- raster::zonal(test[[1]], zones1)
all.equal(zm_runoff, zm_runoff_smooth)
```

### Test whether volume (water balance) is preserved - NO
```{r}
zm_runoff <- raster::zonal(w_rs*area(w_rs), zones1)
zm_runoff_smooth <- raster::zonal(test[[1]]*area(test[[1]]), zones1)
all.equal(zm_runoff, zm_runoff_smooth)
```

## test for any negative values
```{r}
any(round(values(test[[1]]),10) < 0, na.rm=TRUE)
```

## load runoff data and test that water balance is preserved - yes it is
```{r}

runoff <- raster("data/runoff_original_mm.tif")
runoff_smoothed <- raster("data/runoff_smoothed_mm.tif")
zones1 <- raster("data/zones_basins10000km2_mountainslowlands.tif")
crs(zones1) <- crs(runoff)
zones2 <- raster("data/zones_seabasins_mountainslowlands.tif")

#zones1_rs <- resample(zones1, runoff, method="ngb")
runoff_rs <- resample(runoff, zones1, method="ngb")
runoff_sm_rs <- resample(runoff_smoothed, zones1, method="ngb")

nas <- is.na(values(runoff_rs))

#values(runoff_rs) <- values(runoff_rs) * nas

val <- values(zones1)
val[nas] <- NA
values(zones1) <- val


```

```{r}

system.time({
    test <- pycnophylactic_smoothing(runoff_rs, runoff_sm_rs, 
                                     zones1, n=5, 
                                     adjust_threshold = 0.5,
                                     return_error = TRUE, verbose=TRUE)
})

zm_runoff <- raster::zonal(runoff_rs*area(runoff_rs), zones1)
zm_runoff_smooth <- raster::zonal(test[[1]]*area(test[[1]]), zones1)
all.equal(zm_runoff, zm_runoff_smooth)
```


